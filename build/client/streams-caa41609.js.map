{"version":3,"file":"streams-caa41609.js","sources":["../../views/lib/private/streams/streams.js"],"sourcesContent":["/**\n * web-streams-polyfill v2.1.1\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill =\n  typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\"\n    ? Symbol\n    : (description) => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n  // do nothing\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN =\n  Number.isNaN ||\n  function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n  };\n\nconst rethrowAssertionErrorRejection = noop;\n\nfunction typeIsObject(x) {\n  return (typeof x === \"object\" && x !== null) || typeof x === \"function\";\n}\nfunction createArrayFromList(elements) {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n}\nfunction ArrayBufferCopy(dest, destOffset, src, srcOffset, n) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\nfunction IsFiniteNonNegativeNumber(v) {\n  if (IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n  if (v === Infinity) {\n    return false;\n  }\n  return true;\n}\nfunction IsNonNegativeNumber(v) {\n  if (typeof v !== \"number\") {\n    return false;\n  }\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n  if (v < 0) {\n    return false;\n  }\n  return true;\n}\nfunction Call(F, V, args) {\n  if (typeof F !== \"function\") {\n    throw new TypeError(\"Argument is not a function\");\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\nfunction CreateAlgorithmFromUnderlyingMethod(\n  underlyingObject,\n  methodName,\n  algoArgCount,\n  extraArgs\n) {\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== \"function\") {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n      case 1: {\n        return (arg) => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => promiseResolvedWith(undefined);\n}\nfunction InvokeOrNoop(O, P, args) {\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n  return Call(method, O, args);\n}\nfunction PromiseCall(F, V, args) {\n  try {\n    return promiseResolvedWith(Call(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n  return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n  return false;\n}\nfunction ValidateAndNormalizeHighWaterMark(highWaterMark) {\n  highWaterMark = Number(highWaterMark);\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError(\n      \"highWaterMark property of a queuing strategy must be non-negative and non-NaN\"\n    );\n  }\n  return highWaterMark;\n}\nfunction MakeSizeAlgorithmFromSizeFunction(size) {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== \"function\") {\n    throw new TypeError(\n      \"size property of a queuing strategy must be a function\"\n    );\n  }\n  return (chunk) => size(chunk);\n}\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n  return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n  return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n  return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\nfunction uponFulfillment(promise, onFulfilled) {\n  uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n  uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n  constructor() {\n    this._cursor = 0;\n    this._size = 0;\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined,\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n  get length() {\n    return this._size;\n  }\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element) {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined,\n      };\n    }\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift() {\n    // must not be called on an empty queue\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      newFront = oldFront._next;\n      newCursor = 0;\n    }\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined;\n    return element;\n  }\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback) {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        node = node._next;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek() {\n    // must not be called on an empty queue\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  let prototype = null;\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n  const obj = Object.create(prototype);\n  obj.value = value;\n  obj.done = done;\n  return obj;\n}\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._forAuthorCode = true;\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n  if (stream._state === \"readable\") {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === \"closed\") {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n  if (reader._ownerReadableStream._state === \"readable\") {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(\n        \"Reader was released and can no longer be used to monitor the stream's closedness\"\n      )\n    );\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(\n        \"Reader was released and can no longer be used to monitor the stream's closedness\"\n      )\n    );\n  }\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n  return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nconst CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\nconst PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream, forAuthorCode = false) {\n  const reader = new ReadableStreamDefaultReader(stream);\n  reader._forAuthorCode = forAuthorCode;\n  return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream) {\n  const promise = newPromise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n    };\n    stream._reader._readRequests.push(readRequest);\n  });\n  return promise;\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(\n    ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode)\n  );\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n  if (reader === undefined) {\n    return false;\n  }\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n  return true;\n}\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError(\n        \"ReadableStreamDefaultReader can only be constructed with a ReadableStream instance\"\n      );\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError(\n        \"This stream has already been locked for exclusive reading by another reader\"\n      );\n    }\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readRequests = new SimpleQueue();\n  }\n  get closed() {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n    }\n    return this._closedPromise;\n  }\n  cancel(reason) {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n    }\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"cancel\"));\n    }\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n  read() {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n    }\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"read from\"));\n    }\n    return ReadableStreamDefaultReaderRead(this);\n  }\n  releaseLock() {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException(\"releaseLock\");\n    }\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n    if (this._readRequests.length > 0) {\n      throw new TypeError(\n        \"Tried to release a reader lock when that reader has pending read() calls un-settled\"\n      );\n    }\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n    return false;\n  }\n  return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === \"closed\") {\n    return promiseResolvedWith(\n      ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode)\n    );\n  }\n  if (stream._state === \"errored\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  return stream._readableStreamController[PullSteps]();\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`\n  );\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst AsyncIteratorPrototype = Object.getPrototypeOf(\n  Object.getPrototypeOf(async function* () {}).prototype\n);\n\n/// <reference lib=\"es2018.asynciterable\" />\nconst ReadableStreamAsyncIteratorPrototype = {\n  next() {\n    if (IsReadableStreamAsyncIterator(this) === false) {\n      return promiseRejectedWith(\n        streamAsyncIteratorBrandCheckException(\"next\")\n      );\n    }\n    const reader = this._asyncIteratorReader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"iterate\"));\n    }\n    return transformPromiseWith(\n      ReadableStreamDefaultReaderRead(reader),\n      (result) => {\n        const done = result.done;\n        if (done) {\n          ReadableStreamReaderGenericRelease(reader);\n        }\n        const value = result.value;\n        return ReadableStreamCreateReadResult(value, done, true);\n      }\n    );\n  },\n  return(value) {\n    if (IsReadableStreamAsyncIterator(this) === false) {\n      return promiseRejectedWith(\n        streamAsyncIteratorBrandCheckException(\"next\")\n      );\n    }\n    const reader = this._asyncIteratorReader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"finish iterating\"));\n    }\n    if (reader._readRequests.length > 0) {\n      return promiseRejectedWith(\n        new TypeError(\n          \"Tried to release a reader lock when that reader has pending read() calls un-settled\"\n        )\n      );\n    }\n    if (this._preventCancel === false) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () =>\n        ReadableStreamCreateReadResult(value, true, true)\n      );\n    }\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith(\n      ReadableStreamCreateReadResult(value, true, true)\n    );\n  },\n};\nif (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(\n    ReadableStreamAsyncIteratorPrototype,\n    AsyncIteratorPrototype\n  );\n}\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, \"next\", {\n  enumerable: false,\n});\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, \"return\", {\n  enumerable: false,\n});\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel = false) {\n  const reader = AcquireReadableStreamDefaultReader(stream);\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorReader = reader;\n  iterator._preventCancel = Boolean(preventCancel);\n  return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorReader\")) {\n    return false;\n  }\n  return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`\n  );\n}\n\nfunction DequeueValue(container) {\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n  return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError(\n      \"Size must be a finite, non-NaN, non-negative number.\"\n    );\n  }\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n  const pair = container._queue.peek();\n  return pair.value;\n}\nfunction ResetQueue(container) {\n  container._queue = new SimpleQueue();\n  container._queueTotalSize = 0;\n}\n\nconst AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\nconst ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\nclass WritableStream {\n  constructor(underlyingSink = {}, strategy = {}) {\n    InitializeWritableStream(this);\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError(\"Invalid type is specified\");\n    }\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(\n      this,\n      underlyingSink,\n      highWaterMark,\n      sizeAlgorithm\n    );\n  }\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException(\"locked\");\n    }\n    return IsWritableStreamLocked(this);\n  }\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return promiseRejectedWith(streamBrandCheckException(\"abort\"));\n    }\n    if (IsWritableStreamLocked(this) === true) {\n      return promiseRejectedWith(\n        new TypeError(\"Cannot abort a stream that already has a writer\")\n      );\n    }\n    return WritableStreamAbort(this, reason);\n  }\n  close() {\n    if (IsWritableStream(this) === false) {\n      return promiseRejectedWith(streamBrandCheckException(\"close\"));\n    }\n    if (IsWritableStreamLocked(this) === true) {\n      return promiseRejectedWith(\n        new TypeError(\"Cannot close a stream that already has a writer\")\n      );\n    }\n    if (WritableStreamCloseQueuedOrInFlight(this) === true) {\n      return promiseRejectedWith(\n        new TypeError(\"Cannot close an already-closing stream\")\n      );\n    }\n    return WritableStreamClose(this);\n  }\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException(\"getWriter\");\n    }\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(\n  startAlgorithm,\n  writeAlgorithm,\n  closeAlgorithm,\n  abortAlgorithm,\n  highWaterMark = 1,\n  sizeAlgorithm = () => 1\n) {\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n  SetUpWritableStreamDefaultController(\n    stream,\n    controller,\n    startAlgorithm,\n    writeAlgorithm,\n    closeAlgorithm,\n    abortAlgorithm,\n    highWaterMark,\n    sizeAlgorithm\n  );\n  return stream;\n}\nfunction InitializeWritableStream(stream) {\n  stream._state = \"writable\";\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n  stream._writer = undefined;\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n    return false;\n  }\n  return true;\n}\nfunction IsWritableStreamLocked(stream) {\n  if (stream._writer === undefined) {\n    return false;\n  }\n  return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === \"closed\" || state === \"errored\") {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n  let wasAlreadyErroring = false;\n  if (state === \"erroring\") {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n  const promise = newPromise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring,\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n  return promise;\n}\nfunction WritableStreamClose(stream) {\n  const state = stream._state;\n  if (state === \"closed\" || state === \"errored\") {\n    return promiseRejectedWith(\n      new TypeError(\n        `The stream (in ${state} state) is not in the writable state and cannot be closed`\n      )\n    );\n  }\n  const promise = newPromise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject,\n    };\n    stream._closeRequest = closeRequest;\n  });\n  const writer = stream._writer;\n  if (\n    writer !== undefined &&\n    stream._backpressure === true &&\n    state === \"writable\"\n  ) {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n  return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n  const promise = newPromise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject,\n    };\n    stream._writeRequests.push(writeRequest);\n  });\n  return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n  const state = stream._state;\n  if (state === \"writable\") {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n  WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n  const controller = stream._writableStreamController;\n  stream._state = \"erroring\";\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n  if (\n    WritableStreamHasOperationMarkedInFlight(stream) === false &&\n    controller._started === true\n  ) {\n    WritableStreamFinishErroring(stream);\n  }\n}\nfunction WritableStreamFinishErroring(stream) {\n  stream._state = \"errored\";\n  stream._writableStreamController[ErrorSteps]();\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach((writeRequest) => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  const promise = stream._writableStreamController[AbortSteps](\n    abortRequest._reason\n  );\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    },\n    (reason) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }\n  );\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n  WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n  const state = stream._state;\n  if (state === \"erroring\") {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n  stream._state = \"closed\";\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (\n    stream._closeRequest === undefined &&\n    stream._inFlightCloseRequest === undefined\n  ) {\n    return false;\n  }\n  return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (\n    stream._inFlightWriteRequest === undefined &&\n    stream._inFlightCloseRequest === undefined\n  ) {\n    return false;\n  }\n  return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  if (stream._closeRequest !== undefined) {\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n  stream._backpressure = backpressure;\n}\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError(\n        \"WritableStreamDefaultWriter can only be constructed with a WritableStream instance\"\n      );\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError(\n        \"This stream has already been locked for exclusive writing by another writer\"\n      );\n    }\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n    const state = stream._state;\n    if (state === \"writable\") {\n      if (\n        WritableStreamCloseQueuedOrInFlight(stream) === false &&\n        stream._backpressure === true\n      ) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === \"erroring\") {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === \"closed\") {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n    }\n    return this._closedPromise;\n  }\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException(\"desiredSize\");\n    }\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException(\"desiredSize\");\n    }\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n    }\n    return this._readyPromise;\n  }\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n    }\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n    }\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n    }\n    const stream = this._ownerWritableStream;\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException(\"close\"));\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return promiseRejectedWith(\n        new TypeError(\"Cannot close an already-closing stream\")\n      );\n    }\n    return WritableStreamDefaultWriterClose(this);\n  }\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException(\"releaseLock\");\n    }\n    const stream = this._ownerWritableStream;\n    if (stream === undefined) {\n      return;\n    }\n    WritableStreamDefaultWriterRelease(this);\n  }\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n    }\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n    }\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n    return false;\n  }\n  return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n  return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n  return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n  if (\n    WritableStreamCloseQueuedOrInFlight(stream) === true ||\n    state === \"closed\"\n  ) {\n    return promiseResolvedWith(undefined);\n  }\n  if (state === \"errored\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === \"pending\") {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (writer._readyPromiseState === \"pending\") {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n  if (state === \"errored\" || state === \"erroring\") {\n    return null;\n  }\n  if (state === \"closed\") {\n    return 0;\n  }\n  return WritableStreamDefaultControllerGetDesiredSize(\n    stream._writableStreamController\n  );\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  const releasedError = new TypeError(\n    \"Writer was released and can no longer be used to monitor the stream's closedness\"\n  );\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n  const controller = stream._writableStreamController;\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(\n    controller,\n    chunk\n  );\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n  }\n  const state = stream._state;\n  if (state === \"errored\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (\n    WritableStreamCloseQueuedOrInFlight(stream) === true ||\n    state === \"closed\"\n  ) {\n    return promiseRejectedWith(\n      new TypeError(\"The stream is closing or closed and cannot be written to\")\n    );\n  }\n  if (state === \"erroring\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  const promise = WritableStreamAddWriteRequest(stream);\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n}\nclass WritableStreamDefaultController {\n  /** @internal */\n  constructor() {\n    throw new TypeError(\n      \"WritableStreamDefaultController cannot be constructed explicitly\"\n    );\n  }\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        \"WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController\"\n      );\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== \"writable\") {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n    WritableStreamDefaultControllerError(this, e);\n  }\n  /** @internal */\n  [AbortSteps](reason) {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n    return false;\n  }\n  return true;\n}\nfunction SetUpWritableStreamDefaultController(\n  stream,\n  controller,\n  startAlgorithm,\n  writeAlgorithm,\n  closeAlgorithm,\n  abortAlgorithm,\n  highWaterMark,\n  sizeAlgorithm\n) {\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(\n    controller\n  );\n  WritableStreamUpdateBackpressure(stream, backpressure);\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    (r) => {\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n    }\n  );\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(\n  stream,\n  underlyingSink,\n  highWaterMark,\n  sizeAlgorithm\n) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, \"start\", [controller]);\n  }\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingSink,\n    \"write\",\n    1,\n    [controller]\n  );\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingSink,\n    \"close\",\n    0,\n    []\n  );\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingSink,\n    \"abort\",\n    1,\n    []\n  );\n  SetUpWritableStreamDefaultController(\n    stream,\n    controller,\n    startAlgorithm,\n    writeAlgorithm,\n    closeAlgorithm,\n    abortAlgorithm,\n    highWaterMark,\n    sizeAlgorithm\n  );\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, \"close\", 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n  const stream = controller._controlledWritableStream;\n  if (\n    WritableStreamCloseQueuedOrInFlight(stream) === false &&\n    stream._state === \"writable\"\n  ) {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(\n      controller\n    );\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  const stream = controller._controlledWritableStream;\n  if (controller._started === false) {\n    return;\n  }\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n  const state = stream._state;\n  if (state === \"erroring\") {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n  if (controller._queue.length === 0) {\n    return;\n  }\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === \"close\") {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === \"writable\") {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n  WritableStreamMarkCloseRequestInFlight(stream);\n  DequeueValue(controller);\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    (reason) => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  );\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n      const state = stream._state;\n      DequeueValue(controller);\n      if (\n        WritableStreamCloseQueuedOrInFlight(stream) === false &&\n        state === \"writable\"\n      ) {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(\n          controller\n        );\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    (reason) => {\n      if (stream._state === \"writable\") {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  );\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `WritableStream.prototype.${name} can only be used on a WritableStream`\n  );\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`\n  );\n}\nfunction defaultWriterLockException(name) {\n  return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = \"pending\";\n  });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = \"rejected\";\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = \"resolved\";\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = \"pending\";\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = \"rejected\";\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = \"fulfilled\";\n}\n\nfunction isAbortSignal(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    return typeof value.aborted === \"boolean\";\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException =\n  typeof DOMException !== \"undefined\" ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n  if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n    return false;\n  }\n  try {\n    new ctor();\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction createDOMExceptionPolyfill() {\n  const ctor = function DOMException(message, name) {\n    this.message = message || \"\";\n    this.name = name || \"Error\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  };\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, \"constructor\", {\n    value: ctor,\n    writable: true,\n    configurable: true,\n  });\n  return ctor;\n}\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException)\n  ? NativeDOMException\n  : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(\n  source,\n  dest,\n  preventClose,\n  preventAbort,\n  preventCancel,\n  signal\n) {\n  const reader = AcquireReadableStreamDefaultReader(source);\n  const writer = AcquireWritableStreamDefaultWriter(dest);\n  source._disturbed = true;\n  let shuttingDown = false;\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith(undefined);\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = new DOMException$1(\"Aborted\", \"AbortError\");\n        const actions = [];\n        if (preventAbort === false) {\n          actions.push(() => {\n            if (dest._state === \"writable\") {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (preventCancel === false) {\n          actions.push(() => {\n            if (source._state === \"readable\") {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(\n          () => Promise.all(actions.map((action) => action())),\n          true,\n          error\n        );\n      };\n      if (signal.aborted === true) {\n        abortAlgorithm();\n        return;\n      }\n      signal.addEventListener(\"abort\", abortAlgorithm);\n    }\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise((resolveLoop, rejectLoop) => {\n        function next(done) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n        next(false);\n      });\n    }\n    function pipeStep() {\n      if (shuttingDown === true) {\n        return promiseResolvedWith(true);\n      }\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return PerformPromiseThen(\n          ReadableStreamDefaultReaderRead(reader),\n          (result) => {\n            if (result.done === true) {\n              return true;\n            }\n            currentWrite = PerformPromiseThen(\n              WritableStreamDefaultWriterWrite(writer, result.value),\n              undefined,\n              noop\n            );\n            return false;\n          }\n        );\n      });\n    }\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n      if (preventAbort === false) {\n        shutdownWithAction(\n          () => WritableStreamAbort(dest, storedError),\n          true,\n          storedError\n        );\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n      if (preventCancel === false) {\n        shutdownWithAction(\n          () => ReadableStreamCancel(source, storedError),\n          true,\n          storedError\n        );\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (preventClose === false) {\n        shutdownWithAction(() =>\n          WritableStreamDefaultWriterCloseWithErrorPropagation(writer)\n        );\n      } else {\n        shutdown();\n      }\n    });\n    // Closing must be propagated backward\n    if (\n      WritableStreamCloseQueuedOrInFlight(dest) === true ||\n      dest._state === \"closed\"\n    ) {\n      const destClosed = new TypeError(\n        \"the destination writable stream closed before all data could be piped to it\"\n      );\n      if (preventCancel === false) {\n        shutdownWithAction(\n          () => ReadableStreamCancel(source, destClosed),\n          true,\n          destClosed\n        );\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n    setPromiseIsHandledToTrue(pipeLoop());\n    function waitForWritesToFinish() {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(currentWrite, () =>\n        oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n    function isOrBecomesErrored(stream, promise, action) {\n      if (stream._state === \"errored\") {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n    function isOrBecomesClosed(stream, promise, action) {\n      if (stream._state === \"closed\") {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n    function shutdownWithAction(action, originalIsError, originalError) {\n      if (shuttingDown === true) {\n        return;\n      }\n      shuttingDown = true;\n      if (\n        dest._state === \"writable\" &&\n        WritableStreamCloseQueuedOrInFlight(dest) === false\n      ) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n      function doTheRest() {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          (newError) => finalize(true, newError)\n        );\n      }\n    }\n    function shutdown(isError, error) {\n      if (shuttingDown === true) {\n        return;\n      }\n      shuttingDown = true;\n      if (\n        dest._state === \"writable\" &&\n        WritableStreamCloseQueuedOrInFlight(dest) === false\n      ) {\n        uponFulfillment(waitForWritesToFinish(), () =>\n          finalize(isError, error)\n        );\n      } else {\n        finalize(isError, error);\n      }\n    }\n    function finalize(isError, error) {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n      if (signal !== undefined) {\n        signal.removeEventListener(\"abort\", abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n\nclass ReadableStreamDefaultController {\n  /** @internal */\n  constructor() {\n    throw new TypeError();\n  }\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException(\"desiredSize\");\n    }\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException(\"close\");\n    }\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError(\"The stream is not in a state that permits close\");\n    }\n    ReadableStreamDefaultControllerClose(this);\n  }\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException(\"enqueue\");\n    }\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError(\"The stream is not in a state that permits enqueue\");\n    }\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException(\"error\");\n    }\n    ReadableStreamDefaultControllerError(this, e);\n  }\n  /** @internal */\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n  /** @internal */\n  [PullSteps]() {\n    const stream = this._controlledReadableStream;\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n      return promiseResolvedWith(\n        ReadableStreamCreateReadResult(\n          chunk,\n          false,\n          stream._reader._forAuthorCode\n        )\n      );\n    }\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n    return false;\n  }\n  return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return;\n  }\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return;\n  }\n  controller._pulling = true;\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    },\n    (e) => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  );\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n  if (controller._started === false) {\n    return false;\n  }\n  if (\n    IsReadableStreamLocked(stream) === true &&\n    ReadableStreamGetNumReadRequests(stream) > 0\n  ) {\n    return true;\n  }\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n  return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n  controller._closeRequested = true;\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n  if (\n    IsReadableStreamLocked(stream) === true &&\n    ReadableStreamGetNumReadRequests(stream) > 0\n  ) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n  if (stream._state !== \"readable\") {\n    return;\n  }\n  ResetQueue(controller);\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n  if (state === \"errored\") {\n    return null;\n  }\n  if (state === \"closed\") {\n    return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n  return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n  if (controller._closeRequested === false && state === \"readable\") {\n    return true;\n  }\n  return false;\n}\nfunction SetUpReadableStreamDefaultController(\n  stream,\n  controller,\n  startAlgorithm,\n  pullAlgorithm,\n  cancelAlgorithm,\n  highWaterMark,\n  sizeAlgorithm\n) {\n  controller._controlledReadableStream = stream;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  stream._readableStreamController = controller;\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    (r) => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  );\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n  stream,\n  underlyingSource,\n  highWaterMark,\n  sizeAlgorithm\n) {\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, \"start\", [controller]);\n  }\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingSource,\n    \"pull\",\n    0,\n    [controller]\n  );\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingSource,\n    \"cancel\",\n    1,\n    []\n  );\n  SetUpReadableStreamDefaultController(\n    stream,\n    controller,\n    startAlgorithm,\n    pullAlgorithm,\n    cancelAlgorithm,\n    highWaterMark,\n    sizeAlgorithm\n  );\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`\n  );\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  const reader = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n  let resolveCancelPromise;\n  const cancelPromise = newPromise((resolve) => {\n    resolveCancelPromise = resolve;\n  });\n  function pullAlgorithm() {\n    if (reading === true) {\n      return promiseResolvedWith(undefined);\n    }\n    reading = true;\n    const readPromise = transformPromiseWith(\n      ReadableStreamDefaultReaderRead(reader),\n      (result) => {\n        reading = false;\n        const done = result.done;\n        if (done === true) {\n          if (canceled1 === false) {\n            ReadableStreamDefaultControllerClose(\n              branch1._readableStreamController\n            );\n          }\n          if (canceled2 === false) {\n            ReadableStreamDefaultControllerClose(\n              branch2._readableStreamController\n            );\n          }\n          return;\n        }\n        const value = result.value;\n        const value1 = value;\n        const value2 = value;\n        // There is no way to access the cloning code right now in the reference implementation.\n        // If we add one then we'll need an implementation for serializable objects.\n        // if (canceled2 === false && cloneForBranch2 === true) {\n        //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n        // }\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerEnqueue(\n            branch1._readableStreamController,\n            value1\n          );\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerEnqueue(\n            branch2._readableStreamController,\n            value2\n          );\n        }\n      }\n    );\n    setPromiseIsHandledToTrue(readPromise);\n    return promiseResolvedWith(undefined);\n  }\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n  function startAlgorithm() {}\n  branch1 = CreateReadableStream(\n    startAlgorithm,\n    pullAlgorithm,\n    cancel1Algorithm\n  );\n  branch2 = CreateReadableStream(\n    startAlgorithm,\n    pullAlgorithm,\n    cancel2Algorithm\n  );\n  uponRejection(reader._closedPromise, (r) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n  });\n  return [branch1, branch2];\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger =\n  Number.isInteger ||\n  function (value) {\n    return (\n      typeof value === \"number\" &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    );\n  };\n\nclass ReadableStreamBYOBRequest {\n  /** @internal */\n  constructor() {\n    throw new TypeError(\"ReadableStreamBYOBRequest cannot be used directly\");\n  }\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException(\"view\");\n    }\n    return this._view;\n  }\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException(\"respond\");\n    }\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    }\n    if (IsDetachedBuffer(this._view.buffer) === true);\n    ReadableByteStreamControllerRespond(\n      this._associatedReadableByteStreamController,\n      bytesWritten\n    );\n  }\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException(\"respond\");\n    }\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    }\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError(\"You can only respond with array buffer views\");\n    }\n    if (IsDetachedBuffer(view.buffer) === true);\n    ReadableByteStreamControllerRespondWithNewView(\n      this._associatedReadableByteStreamController,\n      view\n    );\n  }\n}\nclass ReadableByteStreamController {\n  /** @internal */\n  constructor() {\n    throw new TypeError(\n      \"ReadableByteStreamController constructor cannot be used directly\"\n    );\n  }\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException(\"byobRequest\");\n    }\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos.peek();\n      const view = new Uint8Array(\n        firstDescriptor.buffer,\n        firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n        firstDescriptor.byteLength - firstDescriptor.bytesFilled\n      );\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n    return this._byobRequest;\n  }\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException(\"desiredSize\");\n    }\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException(\"close\");\n    }\n    if (this._closeRequested === true) {\n      throw new TypeError(\n        \"The stream has already been closed; do not close it again!\"\n      );\n    }\n    const state = this._controlledReadableByteStream._state;\n    if (state !== \"readable\") {\n      throw new TypeError(\n        `The stream (in ${state} state) is not in the readable state and cannot be closed`\n      );\n    }\n    ReadableByteStreamControllerClose(this);\n  }\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException(\"enqueue\");\n    }\n    if (this._closeRequested === true) {\n      throw new TypeError(\"stream is closed or draining\");\n    }\n    const state = this._controlledReadableByteStream._state;\n    if (state !== \"readable\") {\n      throw new TypeError(\n        `The stream (in ${state} state) is not in the readable state and cannot be enqueued to`\n      );\n    }\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError(\n        \"You can only enqueue array buffer views when using a ReadableByteStreamController\"\n      );\n    }\n    if (IsDetachedBuffer(chunk.buffer) === true);\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException(\"error\");\n    }\n    ReadableByteStreamControllerError(this, e);\n  }\n  /** @internal */\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos.peek();\n      firstDescriptor.bytesFilled = 0;\n    }\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n  /** @internal */\n  [PullSteps]() {\n    const stream = this._controlledReadableByteStream;\n    if (this._queueTotalSize > 0) {\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n      ReadableByteStreamControllerHandleQueueDrain(this);\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return promiseRejectedWith(viewE);\n      }\n      return promiseResolvedWith(\n        ReadableStreamCreateReadResult(\n          view,\n          false,\n          stream._reader._forAuthorCode\n        )\n      );\n    }\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return promiseRejectedWith(bufferE);\n      }\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: \"default\",\n      };\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n    const promise = ReadableStreamAddReadRequest(stream);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n    return promise;\n  }\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (\n    !Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")\n  ) {\n    return false;\n  }\n  return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (\n    !Object.prototype.hasOwnProperty.call(\n      x,\n      \"_associatedReadableByteStreamController\"\n    )\n  ) {\n    return false;\n  }\n  return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return;\n  }\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return;\n  }\n  controller._pulling = true;\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    (e) => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  );\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(\n  stream,\n  pullIntoDescriptor\n) {\n  let done = false;\n  if (stream._state === \"closed\") {\n    done = true;\n  }\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(\n    pullIntoDescriptor\n  );\n  if (pullIntoDescriptor.readerType === \"default\") {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(\n  pullIntoDescriptor\n) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n  return new pullIntoDescriptor.ctor(\n    pullIntoDescriptor.buffer,\n    pullIntoDescriptor.byteOffset,\n    bytesFilled / elementSize\n  );\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(\n  controller,\n  buffer,\n  byteOffset,\n  byteLength\n) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(\n  controller,\n  pullIntoDescriptor\n) {\n  const elementSize = pullIntoDescriptor.elementSize;\n  const currentAlignedBytes =\n    pullIntoDescriptor.bytesFilled -\n    (pullIntoDescriptor.bytesFilled % elementSize);\n  const maxBytesToCopy = Math.min(\n    controller._queueTotalSize,\n    pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled\n  );\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining =\n      maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n  const queue = controller._queue;\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n    const bytesToCopy = Math.min(\n      totalBytesToCopyRemaining,\n      headOfQueue.byteLength\n    );\n    const destStart =\n      pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(\n      pullIntoDescriptor.buffer,\n      destStart,\n      headOfQueue.buffer,\n      headOfQueue.byteOffset,\n      bytesToCopy\n    );\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(\n      controller,\n      bytesToCopy,\n      pullIntoDescriptor\n    );\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n  return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(\n  controller,\n  size,\n  pullIntoDescriptor\n) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n  controller\n) {\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n    if (\n      ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(\n        controller,\n        pullIntoDescriptor\n      ) === true\n    ) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableByteStream;\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n  const ctor = view.constructor;\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: \"byob\",\n  };\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n  if (stream._state === \"closed\") {\n    const emptyView = new ctor(\n      pullIntoDescriptor.buffer,\n      pullIntoDescriptor.byteOffset,\n      0\n    );\n    return promiseResolvedWith(\n      ReadableStreamCreateReadResult(\n        emptyView,\n        true,\n        stream._reader._forAuthorCode\n      )\n    );\n  }\n  if (controller._queueTotalSize > 0) {\n    if (\n      ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(\n        controller,\n        pullIntoDescriptor\n      ) === true\n    ) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(\n        pullIntoDescriptor\n      );\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n      return promiseResolvedWith(\n        ReadableStreamCreateReadResult(\n          filledView,\n          false,\n          stream._reader._forAuthorCode\n        )\n      );\n    }\n    if (controller._closeRequested === true) {\n      const e = new TypeError(\n        \"Insufficient bytes to fill elements in the given buffer\"\n      );\n      ReadableByteStreamControllerError(controller, e);\n      return promiseRejectedWith(e);\n    }\n  }\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n  return promise;\n}\nfunction ReadableByteStreamControllerRespondInClosedState(\n  controller,\n  firstDescriptor\n) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(\n        controller\n      );\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        stream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(\n  controller,\n  bytesWritten,\n  pullIntoDescriptor\n) {\n  if (\n    pullIntoDescriptor.bytesFilled + bytesWritten >\n    pullIntoDescriptor.byteLength\n  ) {\n    throw new RangeError(\"bytesWritten out of range\");\n  }\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(\n    controller,\n    bytesWritten,\n    pullIntoDescriptor\n  );\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  const remainderSize =\n    pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(\n      controller,\n      remainder,\n      0,\n      remainder.byteLength\n    );\n  }\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(\n    controller._controlledReadableByteStream,\n    pullIntoDescriptor\n  );\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const stream = controller._controlledReadableByteStream;\n  if (stream._state === \"closed\") {\n    if (bytesWritten !== 0) {\n      throw new TypeError(\n        \"bytesWritten must be 0 when calling respond() on a closed stream\"\n      );\n    }\n    ReadableByteStreamControllerRespondInClosedState(\n      controller,\n      firstDescriptor\n    );\n  } else {\n    ReadableByteStreamControllerRespondInReadableState(\n      controller,\n      bytesWritten,\n      firstDescriptor\n    );\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n  if (stream._state !== \"readable\") {\n    return false;\n  }\n  if (controller._closeRequested === true) {\n    return false;\n  }\n  if (controller._started === false) {\n    return false;\n  }\n  if (\n    ReadableStreamHasDefaultReader(stream) === true &&\n    ReadableStreamGetNumReadRequests(stream) > 0\n  ) {\n    return true;\n  }\n  if (\n    ReadableStreamHasBYOBReader(stream) === true &&\n    ReadableStreamGetNumReadIntoRequests(stream) > 0\n  ) {\n    return true;\n  }\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n  return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n    return;\n  }\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError(\n        \"Insufficient bytes to fill elements in the given buffer\"\n      );\n      ReadableByteStreamControllerError(controller, e);\n      throw e;\n    }\n  }\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(\n        controller,\n        transferredBuffer,\n        byteOffset,\n        byteLength\n      );\n    } else {\n      const transferredView = new Uint8Array(\n        transferredBuffer,\n        byteOffset,\n        byteLength\n      );\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(\n      controller,\n      transferredBuffer,\n      byteOffset,\n      byteLength\n    );\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n      controller\n    );\n  } else {\n    ReadableByteStreamControllerEnqueueChunkToQueue(\n      controller,\n      transferredBuffer,\n      byteOffset,\n      byteLength\n    );\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n  if (stream._state !== \"readable\") {\n    return;\n  }\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n  if (state === \"errored\") {\n    return null;\n  }\n  if (state === \"closed\") {\n    return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError(\"bytesWritten must be a finite\");\n  }\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  if (\n    firstDescriptor.byteOffset + firstDescriptor.bytesFilled !==\n    view.byteOffset\n  ) {\n    throw new RangeError(\n      \"The region specified by view does not match byobRequest\"\n    );\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError(\n      \"The buffer of view has different capacity than byobRequest\"\n    );\n  }\n  firstDescriptor.buffer = view.buffer;\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(\n  stream,\n  controller,\n  startAlgorithm,\n  pullAlgorithm,\n  cancelAlgorithm,\n  highWaterMark,\n  autoAllocateChunkSize\n) {\n  controller._controlledReadableByteStream = stream;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._byobRequest = undefined;\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._closeRequested = false;\n  controller._started = false;\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n  controller._pendingPullIntos = new SimpleQueue();\n  stream._readableStreamController = controller;\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    },\n    (r) => {\n      ReadableByteStreamControllerError(controller, r);\n    }\n  );\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream,\n  underlyingByteSource,\n  highWaterMark\n) {\n  const controller = Object.create(ReadableByteStreamController.prototype);\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, \"start\", [controller]);\n  }\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingByteSource,\n    \"pull\",\n    0,\n    [controller]\n  );\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    underlyingByteSource,\n    \"cancel\",\n    1,\n    []\n  );\n  let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n    if (\n      NumberIsInteger(autoAllocateChunkSize) === false ||\n      autoAllocateChunkSize <= 0\n    ) {\n      throw new RangeError(\"autoAllocateChunkSize must be a positive integer\");\n    }\n  }\n  SetUpReadableByteStreamController(\n    stream,\n    controller,\n    startAlgorithm,\n    pullAlgorithm,\n    cancelAlgorithm,\n    highWaterMark,\n    autoAllocateChunkSize\n  );\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`\n  );\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`\n  );\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream, forAuthorCode = false) {\n  const reader = new ReadableStreamBYOBReader(stream);\n  reader._forAuthorCode = forAuthorCode;\n  return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  const promise = newPromise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n    };\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n  return promise;\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(\n    ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode)\n  );\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n  if (reader === undefined) {\n    return false;\n  }\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n  return true;\n}\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError(\n        \"ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a \" +\n          \"byte source\"\n      );\n    }\n    if (\n      IsReadableByteStreamController(stream._readableStreamController) === false\n    ) {\n      throw new TypeError(\n        \"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" +\n          \"source\"\n      );\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError(\n        \"This stream has already been locked for exclusive reading by another reader\"\n      );\n    }\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readIntoRequests = new SimpleQueue();\n  }\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n    }\n    return this._closedPromise;\n  }\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n    }\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"cancel\"));\n    }\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n    }\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException(\"read from\"));\n    }\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(\n        new TypeError(\"view must be an array buffer view\")\n      );\n    }\n    if (IsDetachedBuffer(view.buffer) === true);\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(\n        new TypeError(\"view must have non-zero byteLength\")\n      );\n    }\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException(\"releaseLock\");\n    }\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError(\n        \"Tried to release a reader lock when that reader has pending read() calls un-settled\"\n      );\n    }\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n    return false;\n  }\n  return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === \"errored\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(\n    stream._readableStreamController,\n    view\n  );\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`\n  );\n}\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, strategy = {}) {\n    InitializeReadableStream(this);\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === \"bytes\") {\n      if (size !== undefined) {\n        throw new RangeError(\n          \"The strategy for a byte stream cannot have a size function\"\n        );\n      }\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark\n      );\n    } else if (type === undefined) {\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    } else {\n      throw new RangeError(\"Invalid type is specified\");\n    }\n  }\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1(\"locked\");\n    }\n    return IsReadableStreamLocked(this);\n  }\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n    }\n    if (IsReadableStreamLocked(this) === true) {\n      return promiseRejectedWith(\n        new TypeError(\"Cannot cancel a stream that already has a reader\")\n      );\n    }\n    return ReadableStreamCancel(this, reason);\n  }\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1(\"getReader\");\n    }\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this, true);\n    }\n    mode = String(mode);\n    if (mode === \"byob\") {\n      return AcquireReadableStreamBYOBReader(this, true);\n    }\n    throw new RangeError(\"Invalid mode is specified\");\n  }\n  pipeThrough(\n    { writable, readable },\n    { preventClose, preventAbort, preventCancel, signal } = {}\n  ) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1(\"pipeThrough\");\n    }\n    if (IsWritableStream(writable) === false) {\n      throw new TypeError(\n        \"writable argument to pipeThrough must be a WritableStream\"\n      );\n    }\n    if (IsReadableStream(readable) === false) {\n      throw new TypeError(\n        \"readable argument to pipeThrough must be a ReadableStream\"\n      );\n    }\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      throw new TypeError(\n        \"ReadableStream.prototype.pipeThrough's signal option must be an AbortSignal\"\n      );\n    }\n    if (IsReadableStreamLocked(this) === true) {\n      throw new TypeError(\n        \"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\"\n      );\n    }\n    if (IsWritableStreamLocked(writable) === true) {\n      throw new TypeError(\n        \"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\"\n      );\n    }\n    const promise = ReadableStreamPipeTo(\n      this,\n      writable,\n      preventClose,\n      preventAbort,\n      preventCancel,\n      signal\n    );\n    setPromiseIsHandledToTrue(promise);\n    return readable;\n  }\n  pipeTo(dest, { preventClose, preventAbort, preventCancel, signal } = {}) {\n    if (IsReadableStream(this) === false) {\n      return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n    }\n    if (IsWritableStream(dest) === false) {\n      return promiseRejectedWith(\n        new TypeError(\n          \"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"\n        )\n      );\n    }\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      return promiseRejectedWith(\n        new TypeError(\n          \"ReadableStream.prototype.pipeTo's signal option must be an AbortSignal\"\n        )\n      );\n    }\n    if (IsReadableStreamLocked(this) === true) {\n      return promiseRejectedWith(\n        new TypeError(\n          \"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"\n        )\n      );\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return promiseRejectedWith(\n        new TypeError(\n          \"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"\n        )\n      );\n    }\n    return ReadableStreamPipeTo(\n      this,\n      dest,\n      preventClose,\n      preventAbort,\n      preventCancel,\n      signal\n    );\n  }\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1(\"tee\");\n    }\n    const branches = ReadableStreamTee(this);\n    return createArrayFromList(branches);\n  }\n  getIterator({ preventCancel = false } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1(\"getIterator\");\n    }\n    return AcquireReadableStreamAsyncIterator(this, preventCancel);\n  }\n}\nif (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n  Object.defineProperty(\n    ReadableStream.prototype,\n    SymbolPolyfill.asyncIterator,\n    {\n      value: ReadableStream.prototype.getIterator,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    }\n  );\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(\n  startAlgorithm,\n  pullAlgorithm,\n  cancelAlgorithm,\n  highWaterMark = 1,\n  sizeAlgorithm = () => 1\n) {\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream,\n    controller,\n    startAlgorithm,\n    pullAlgorithm,\n    cancelAlgorithm,\n    highWaterMark,\n    sizeAlgorithm\n  );\n  return stream;\n}\nfunction InitializeReadableStream(stream) {\n  stream._state = \"readable\";\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n    return false;\n  }\n  return true;\n}\nfunction IsReadableStreamLocked(stream) {\n  if (stream._reader === undefined) {\n    return false;\n  }\n  return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n  if (stream._state === \"closed\") {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === \"errored\") {\n    return promiseRejectedWith(stream._storedError);\n  }\n  ReadableStreamClose(stream);\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](\n    reason\n  );\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n  stream._state = \"closed\";\n  const reader = stream._reader;\n  if (reader === undefined) {\n    return;\n  }\n  if (IsReadableStreamDefaultReader(reader)) {\n    reader._readRequests.forEach((readRequest) => {\n      readRequest._resolve(\n        ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode)\n      );\n    });\n    reader._readRequests = new SimpleQueue();\n  }\n  defaultReaderClosedPromiseResolve(reader);\n}\nfunction ReadableStreamError(stream, e) {\n  stream._state = \"errored\";\n  stream._storedError = e;\n  const reader = stream._reader;\n  if (reader === undefined) {\n    return;\n  }\n  if (IsReadableStreamDefaultReader(reader)) {\n    reader._readRequests.forEach((readRequest) => {\n      readRequest._reject(e);\n    });\n    reader._readRequests = new SimpleQueue();\n  } else {\n    reader._readIntoRequests.forEach((readIntoRequest) => {\n      readIntoRequest._reject(e);\n    });\n    reader._readIntoRequests = new SimpleQueue();\n  }\n  defaultReaderClosedPromiseReject(reader, e);\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n  return new TypeError(\n    `ReadableStream.prototype.${name} can only be used on a ReadableStream`\n  );\n}\n\nclass ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    this.highWaterMark = highWaterMark;\n  }\n  size(chunk) {\n    return chunk.byteLength;\n  }\n}\n\nclass CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    this.highWaterMark = highWaterMark;\n  }\n  size() {\n    return 1;\n  }\n}\n\n// Class TransformStream\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const writableSizeFunction = writableStrategy.size;\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    const readableSizeFunction = readableStrategy.size;\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n    const writableType = transformer.writableType;\n    if (writableType !== undefined) {\n      throw new RangeError(\"Invalid writable type specified\");\n    }\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(\n      writableSizeFunction\n    );\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(\n      writableHighWaterMark\n    );\n    const readableType = transformer.readableType;\n    if (readableType !== undefined) {\n      throw new RangeError(\"Invalid readable type specified\");\n    }\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(\n      readableSizeFunction\n    );\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(\n      readableHighWaterMark\n    );\n    let startPromise_resolve;\n    const startPromise = newPromise((resolve) => {\n      startPromise_resolve = resolve;\n    });\n    InitializeTransformStream(\n      this,\n      startPromise,\n      writableHighWaterMark,\n      writableSizeAlgorithm,\n      readableHighWaterMark,\n      readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n    const startResult = InvokeOrNoop(transformer, \"start\", [\n      this._transformStreamController,\n    ]);\n    startPromise_resolve(startResult);\n  }\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException$2(\"readable\");\n    }\n    return this._readable;\n  }\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException$2(\"writable\");\n    }\n    return this._writable;\n  }\n}\nfunction InitializeTransformStream(\n  stream,\n  startPromise,\n  writableHighWaterMark,\n  writableSizeAlgorithm,\n  readableHighWaterMark,\n  readableSizeAlgorithm\n) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n  stream._writable = CreateWritableStream(\n    startAlgorithm,\n    writeAlgorithm,\n    closeAlgorithm,\n    abortAlgorithm,\n    writableHighWaterMark,\n    writableSizeAlgorithm\n  );\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return promiseResolvedWith(undefined);\n  }\n  stream._readable = CreateReadableStream(\n    startAlgorithm,\n    pullAlgorithm,\n    cancelAlgorithm,\n    readableHighWaterMark,\n    readableSizeAlgorithm\n  );\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n    return false;\n  }\n  return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  ReadableStreamDefaultControllerError(\n    stream._readable._readableStreamController,\n    e\n  );\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(\n    stream._transformStreamController\n  );\n  WritableStreamDefaultControllerErrorIfNeeded(\n    stream._writable._writableStreamController,\n    e\n  );\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  // Passes also when called during construction.\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n  stream._backpressureChangePromise = newPromise((resolve) => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n  stream._backpressure = backpressure;\n}\nclass TransformStreamDefaultController {\n  /** @internal */\n  constructor() {\n    throw new TypeError(\n      \"TransformStreamDefaultController instances cannot be created directly\"\n    );\n  }\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1(\"desiredSize\");\n    }\n    const readableController = this._controlledTransformStream._readable\n      ._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1(\"enqueue\");\n    }\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1(\"error\");\n    }\n    TransformStreamDefaultControllerError(this, reason);\n  }\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1(\"terminate\");\n    }\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n    return false;\n  }\n  return true;\n}\nfunction SetUpTransformStreamDefaultController(\n  stream,\n  controller,\n  transformAlgorithm,\n  flushAlgorithm\n) {\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(\n  stream,\n  transformer\n) {\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n  let transformAlgorithm = (chunk) => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return promiseResolvedWith(undefined);\n    } catch (transformResultE) {\n      return promiseRejectedWith(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== \"function\") {\n      throw new TypeError(\"transform is not a method\");\n    }\n    transformAlgorithm = (chunk) =>\n      PromiseCall(transformMethod, transformer, [chunk, controller]);\n  }\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(\n    transformer,\n    \"flush\",\n    0,\n    [controller]\n  );\n  SetUpTransformStreamDefaultController(\n    stream,\n    controller,\n    transformAlgorithm,\n    flushAlgorithm\n  );\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (\n    ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) ===\n    false\n  ) {\n    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n  }\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    throw stream._readable._storedError;\n  }\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(\n    readableController\n  );\n  if (backpressure !== stream._backpressure) {\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, (r) => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (\n    ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) ===\n    true\n  ) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n  const error = new TypeError(\"TransformStream terminated\");\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  const controller = stream._transformStreamController;\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === \"erroring\") {\n        throw writable._storedError;\n      }\n      return TransformStreamDefaultControllerPerformTransform(\n        controller,\n        chunk\n      );\n    });\n  }\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n  // Return a promise that is fulfilled with undefined on success.\n  return transformPromiseWith(\n    flushPromise,\n    () => {\n      if (readable._state === \"errored\") {\n        throw readable._storedError;\n      }\n      const readableController = readable._readableStreamController;\n      if (\n        ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) ===\n        true\n      ) {\n        ReadableStreamDefaultControllerClose(readableController);\n      }\n    },\n    (r) => {\n      TransformStreamError(stream, r);\n      throw readable._storedError;\n    }\n  );\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  TransformStreamSetBackpressure(stream, false);\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`\n  );\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException$2(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`\n  );\n}\n\nexport {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream,\n};\n//# sourceMappingURL=ponyfill.es2018.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","NumberIsNaN","Number","isNaN","x","rethrowAssertionErrorRejection","typeIsObject","createArrayFromList","elements","slice","IsFiniteNonNegativeNumber","v","IsNonNegativeNumber","Infinity","Call","F","V","args","TypeError","Function","prototype","apply","call","CreateAlgorithmFromUnderlyingMethod","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","PromiseCall","arg","fullArgs","concat","promiseResolvedWith","InvokeOrNoop","O","P","value","promiseRejectedWith","ValidateAndNormalizeHighWaterMark","highWaterMark","RangeError","MakeSizeAlgorithmFromSizeFunction","size","chunk","originalPromise","Promise","originalPromiseThen","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","reason","PerformPromiseThen","promise","onFulfilled","onRejected","uponPromise","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","SimpleQueue","[object Object]","this","_cursor","_size","_front","_elements","_next","_back","length","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","push","oldFront","newFront","oldCursor","newCursor","callback","i","node","front","cursor","ReadableStreamCreateReadResult","done","forAuthorCode","Object","obj","create","ReadableStreamReaderGenericInitialize","reader","stream","_forAuthorCode","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","CancelSteps","PullSteps","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_resolve","_reject","_readRequests","ReadableStreamFulfillReadRequest","shift","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStream","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","ReadableStreamDefaultReaderRead","hasOwnProperty","_disturbed","_readableStreamController","AsyncIteratorPrototype","getPrototypeOf","async","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","streamAsyncIteratorBrandCheckException","_asyncIteratorReader","result","_preventCancel","DequeueValue","container","pair","_queue","_queueTotalSize","EnqueueValueWithSize","ResetQueue","setPrototypeOf","defineProperty","enumerable","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","type","sizeAlgorithm","controller","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","state","_promise","wasAlreadyErroring","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","forEach","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","ready","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","e","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","startAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","r","peek","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","isAbortSignal","aborted","NativeDOMException","DOMException","DOMException$1","ctor","isDOMExceptionConstructor","message","Error","captureStackTrace","constructor","writable","configurable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","dest","preventClose","preventAbort","preventCancel","signal","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","next","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","_closeRequested","ReadableStreamClose","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableStreamError","SetUpReadableStreamDefaultController","pullAlgorithm","cancelAlgorithm","NumberIsInteger","isInteger","isFinite","Math","floor","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","buffer","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","ArrayBuffer","isView","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","byteLength","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","entry","ReadableByteStreamControllerHandleQueueDrain","viewE","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","readerType","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","destOffset","src","srcOffset","n","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","readIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ReadableStream","underlyingSource","InitializeReadableStream","String","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","mode","AcquireReadableStreamBYOBReader","readable","Boolean","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","AcquireReadableStreamAsyncIterator","asyncIterator","getIterator","IsTransformStream","TransformStreamError","_readable","TransformStreamErrorWritableAndUnblockWrite","TransformStreamDefaultControllerClearAlgorithms","_transformStreamController","_writable","TransformStreamSetBackpressure","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamDefaultController","IsTransformStreamDefaultController","defaultControllerBrandCheckException$1","_controlledTransformStream","TransformStreamDefaultControllerEnqueue","readableController","TransformStreamDefaultControllerTerminate","_transformAlgorithm","_flushAlgorithm","ReadableStreamDefaultControllerHasBackpressure","TransformStreamDefaultControllerPerformTransform","streamBrandCheckException$2","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","startPromise","CreateWritableStream","TransformStreamDefaultSinkWriteAlgorithm","flushPromise","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","InitializeTransformStream","transformAlgorithm","transformResultE","transformMethod","transform","flushAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","startResult"],"mappings":"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"}