{"version":3,"file":"streams-6a7ac95a.js","sources":["../../views/lib/private/streams/streams.js"],"sourcesContent":["/**\n * web-streams-polyfill v2.1.1\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    // do nothing\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nconst rethrowAssertionErrorRejection =  noop;\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction createArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction ArrayBufferCopy(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\nfunction IsFiniteNonNegativeNumber(v) {\n    if (IsNonNegativeNumber(v) === false) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\nfunction Call(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction CreateAlgorithmFromUnderlyingMethod(underlyingObject, methodName, algoArgCount, extraArgs) {\n    const method = underlyingObject[methodName];\n    if (method !== undefined) {\n        if (typeof method !== 'function') {\n            throw new TypeError(`${method} is not a method`);\n        }\n        switch (algoArgCount) {\n            case 0: {\n                return () => {\n                    return PromiseCall(method, underlyingObject, extraArgs);\n                };\n            }\n            case 1: {\n                return arg => {\n                    const fullArgs = [arg].concat(extraArgs);\n                    return PromiseCall(method, underlyingObject, fullArgs);\n                };\n            }\n        }\n    }\n    return () => promiseResolvedWith(undefined);\n}\nfunction InvokeOrNoop(O, P, args) {\n    const method = O[P];\n    if (method === undefined) {\n        return undefined;\n    }\n    return Call(method, O, args);\n}\nfunction PromiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(Call(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\nfunction ValidateAndNormalizeHighWaterMark(highWaterMark) {\n    highWaterMark = Number(highWaterMark);\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n    }\n    return highWaterMark;\n}\nfunction MakeSizeAlgorithmFromSizeFunction(size) {\n    if (size === undefined) {\n        return () => 1;\n    }\n    if (typeof size !== 'function') {\n        throw new TypeError('size property of a queuing strategy must be a function');\n    }\n    return chunk => size(chunk);\n}\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n    let prototype = null;\n    if (forAuthorCode === true) {\n        prototype = Object.prototype;\n    }\n    const obj = Object.create(prototype);\n    obj.value = value;\n    obj.done = done;\n    return obj;\n}\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._forAuthorCode = true;\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream, forAuthorCode = false) {\n    const reader = new ReadableStreamDefaultReader(stream);\n    reader._forAuthorCode = forAuthorCode;\n    return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const readRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._reader._readRequests.push(readRequest);\n    });\n    return promise;\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        if (IsReadableStream(stream) === false) {\n            throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n        }\n        if (IsReadableStreamLocked(stream) === true) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    cancel(reason) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        return ReadableStreamDefaultReaderRead(this);\n    }\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return stream._readableStreamController[PullSteps]();\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\n\n/// <reference lib=\"es2018.asynciterable\" />\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (IsReadableStreamAsyncIterator(this) === false) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        const reader = this._asyncIteratorReader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        return transformPromiseWith(ReadableStreamDefaultReaderRead(reader), result => {\n            const done = result.done;\n            if (done) {\n                ReadableStreamReaderGenericRelease(reader);\n            }\n            const value = result.value;\n            return ReadableStreamCreateReadResult(value, done, true);\n        });\n    },\n    return(value) {\n        if (IsReadableStreamAsyncIterator(this) === false) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        const reader = this._asyncIteratorReader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (reader._readRequests.length > 0) {\n            return promiseRejectedWith(new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled'));\n        }\n        if (this._preventCancel === false) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ReadableStreamCreateReadResult(value, true, true));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith(ReadableStreamCreateReadResult(value, true, true));\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, 'next', { enumerable: false });\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, 'return', { enumerable: false });\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel = false) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorReader = reader;\n    iterator._preventCancel = Boolean(preventCancel);\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorReader')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nclass WritableStream {\n    constructor(underlyingSink = {}, strategy = {}) {\n        InitializeWritableStream(this);\n        const size = strategy.size;\n        let highWaterMark = strategy.highWaterMark;\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n        if (highWaterMark === undefined) {\n            highWaterMark = 1;\n        }\n        highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    get locked() {\n        if (IsWritableStream(this) === false) {\n            throw streamBrandCheckException('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    abort(reason) {\n        if (IsWritableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException('abort'));\n        }\n        if (IsWritableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    close() {\n        if (IsWritableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException('close'));\n        }\n        if (IsWritableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    getWriter() {\n        if (IsWritableStream(this) === false) {\n            throw streamBrandCheckException('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (wasAlreadyErroring === false) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure === true && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring === true) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure === true) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        if (IsWritableStream(stream) === false) {\n            throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n        }\n        if (IsWritableStreamLocked(stream) === true) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    get closed() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    get desiredSize() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    get ready() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    abort(reason) {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    close() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    releaseLock() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk) {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nclass WritableStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n    }\n    error(e) {\n        if (IsWritableStreamDefaultController(this) === false) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingSink, 'start', [controller]);\n    }\n    const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n    const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n    const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, 'close', 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    const writeRecord = { chunk };\n    try {\n        EnqueueValueWithSize(controller, writeRecord, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (controller._started === false) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const writeRecord = PeekQueueValue(controller);\n    if (writeRecord === 'close') {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (preventAbort === false) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (preventCancel === false) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted === true) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown === true) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return PerformPromiseThen(ReadableStreamDefaultReaderRead(reader), result => {\n                    if (result.done === true) {\n                        return true;\n                    }\n                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, result.value), undefined, noop);\n                    return false;\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (preventAbort === false) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (preventCancel === false) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (preventClose === false) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (preventCancel === false) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown === true) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown === true) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\nclass ReadableStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError();\n    }\n    get desiredSize() {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    close() {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('close');\n        }\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    error(e) {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps]() {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested === true && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            return promiseResolvedWith(ReadableStreamCreateReadResult(chunk, false, stream._reader._forAuthorCode));\n        }\n        const pendingPromise = ReadableStreamAddReadRequest(stream);\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        return pendingPromise;\n    }\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (shouldPull === false) {\n        return;\n    }\n    if (controller._pulling === true) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain === true) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n        return false;\n    }\n    if (controller._started === false) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const stream = controller._controlledReadableStream;\n    const state = stream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (controller._closeRequested === false && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingSource, 'start', [controller]);\n    }\n    const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n    const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading === true) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readPromise = transformPromiseWith(ReadableStreamDefaultReaderRead(reader), result => {\n            reading = false;\n            const done = result.done;\n            if (done === true) {\n                if (canceled1 === false) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (canceled2 === false) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                return;\n            }\n            const value = result.value;\n            const value1 = value;\n            const value2 = value;\n            // There is no way to access the cloning code right now in the reference implementation.\n            // If we add one then we'll need an implementation for serializable objects.\n            // if (canceled2 === false && cloneForBranch2 === true) {\n            //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n            // }\n            if (canceled1 === false) {\n                ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n            }\n            if (canceled2 === false) {\n                ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n            }\n        });\n        setPromiseIsHandledToTrue(readPromise);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2 === true) {\n            const compositeReason = createArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1 === true) {\n            const compositeReason = createArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() { }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    });\n    return [branch1, branch2];\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n    return typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value;\n};\n\nclass ReadableStreamBYOBRequest {\n    /** @internal */\n    constructor() {\n        throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n    }\n    get view() {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer) === true) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (IsDetachedBuffer(view.buffer) === true) ;\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nclass ReadableByteStreamController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n    }\n    get byobRequest() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    get desiredSize() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    close() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested === true) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        if (this._closeRequested === true) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n        }\n        if (IsDetachedBuffer(chunk.buffer) === true) ;\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    error(e) {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps]() {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            let view;\n            try {\n                view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            }\n            catch (viewE) {\n                return promiseRejectedWith(viewE);\n            }\n            return promiseResolvedWith(ReadableStreamCreateReadResult(view, false, stream._reader._forAuthorCode));\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                return promiseRejectedWith(bufferE);\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                ctor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        const promise = ReadableStreamAddReadRequest(stream);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n        return promise;\n    }\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (shouldPull === false) {\n        return;\n    }\n    if (controller._pulling === true) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain === true) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === undefined) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = undefined;\n    controller._byobRequest = undefined;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        return ReadableStreamAddReadIntoRequest(stream);\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        return promiseResolvedWith(ReadableStreamCreateReadResult(emptyView, true, stream._reader._forAuthorCode));\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            return promiseResolvedWith(ReadableStreamCreateReadResult(filledView, false, stream._reader._forAuthorCode));\n        }\n        if (controller._closeRequested === true) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            return promiseRejectedWith(e);\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    const promise = ReadableStreamAddReadIntoRequest(stream);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n    return promise;\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream) === true) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested === true) {\n        return false;\n    }\n    if (controller._started === false) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream) === true) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream) === true) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const stream = controller._controlledReadableByteStream;\n    const state = stream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = undefined;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n    }\n    const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n    const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n    let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n        autoAllocateChunkSize = Number(autoAllocateChunkSize);\n        if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n            throw new RangeError('autoAllocateChunkSize must be a positive integer');\n        }\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream, forAuthorCode = false) {\n    const reader = new ReadableStreamBYOBReader(stream);\n    reader._forAuthorCode = forAuthorCode;\n    return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const readIntoRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    });\n    return promise;\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        if (!IsReadableStream(stream)) {\n            throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n                'byte source');\n        }\n        if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    cancel(reason) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (IsDetachedBuffer(view.buffer) === true) ;\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        return ReadableStreamBYOBReaderRead(this, view);\n    }\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    // Controllers must implement this.\n    return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nclass ReadableStream {\n    constructor(underlyingSource = {}, strategy = {}) {\n        InitializeReadableStream(this);\n        const size = strategy.size;\n        let highWaterMark = strategy.highWaterMark;\n        const type = underlyingSource.type;\n        const typeString = String(type);\n        if (typeString === 'bytes') {\n            if (size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            if (highWaterMark === undefined) {\n                highWaterMark = 0;\n            }\n            highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else if (type === undefined) {\n            const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n            if (highWaterMark === undefined) {\n                highWaterMark = 1;\n            }\n            highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n        else {\n            throw new RangeError('Invalid type is specified');\n        }\n    }\n    get locked() {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    cancel(reason) {\n        if (IsReadableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader({ mode } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        if (mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this, true);\n        }\n        mode = String(mode);\n        if (mode === 'byob') {\n            return AcquireReadableStreamBYOBReader(this, true);\n        }\n        throw new RangeError('Invalid mode is specified');\n    }\n    pipeThrough({ writable, readable }, { preventClose, preventAbort, preventCancel, signal } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        if (IsWritableStream(writable) === false) {\n            throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n        }\n        if (IsReadableStream(readable) === false) {\n            throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n        }\n        preventClose = Boolean(preventClose);\n        preventAbort = Boolean(preventAbort);\n        preventCancel = Boolean(preventCancel);\n        if (signal !== undefined && !isAbortSignal(signal)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(writable) === true) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n        setPromiseIsHandledToTrue(promise);\n        return readable;\n    }\n    pipeTo(dest, { preventClose, preventAbort, preventCancel, signal } = {}) {\n        if (IsReadableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (IsWritableStream(dest) === false) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n        }\n        preventClose = Boolean(preventClose);\n        preventAbort = Boolean(preventAbort);\n        preventCancel = Boolean(preventCancel);\n        if (signal !== undefined && !isAbortSignal(signal)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(dest) === true) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n    }\n    tee() {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return createArrayFromList(branches);\n    }\n    getIterator({ preventCancel = false } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('getIterator');\n        }\n        return AcquireReadableStreamAsyncIterator(this, preventCancel);\n    }\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.getIterator,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._resolve(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._reject(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._reject(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nclass ByteLengthQueuingStrategy {\n    constructor({ highWaterMark }) {\n        this.highWaterMark = highWaterMark;\n    }\n    size(chunk) {\n        return chunk.byteLength;\n    }\n}\n\nclass CountQueuingStrategy {\n    constructor({ highWaterMark }) {\n        this.highWaterMark = highWaterMark;\n    }\n    size() {\n        return 1;\n    }\n}\n\n// Class TransformStream\nclass TransformStream {\n    constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n        const writableSizeFunction = writableStrategy.size;\n        let writableHighWaterMark = writableStrategy.highWaterMark;\n        const readableSizeFunction = readableStrategy.size;\n        let readableHighWaterMark = readableStrategy.highWaterMark;\n        const writableType = transformer.writableType;\n        if (writableType !== undefined) {\n            throw new RangeError('Invalid writable type specified');\n        }\n        const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n        if (writableHighWaterMark === undefined) {\n            writableHighWaterMark = 1;\n        }\n        writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n        const readableType = transformer.readableType;\n        if (readableType !== undefined) {\n            throw new RangeError('Invalid readable type specified');\n        }\n        const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n        if (readableHighWaterMark === undefined) {\n            readableHighWaterMark = 0;\n        }\n        readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n        startPromise_resolve(startResult);\n    }\n    get readable() {\n        if (IsTransformStream(this) === false) {\n            throw streamBrandCheckException$2('readable');\n        }\n        return this._readable;\n    }\n    get writable() {\n        if (IsTransformStream(this) === false) {\n            throw streamBrandCheckException$2('writable');\n        }\n        return this._writable;\n    }\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure === true) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\nclass TransformStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n    }\n    get desiredSize() {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk) {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    error(reason) {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    terminate() {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    const transformMethod = transformer.transform;\n    if (transformMethod !== undefined) {\n        if (typeof transformMethod !== 'function') {\n            throw new TypeError('transform is not a method');\n        }\n        transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n    }\n    const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n        ReadableStreamDefaultControllerClose(readableController);\n    }\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure === true) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        const readableController = readable._readableStreamController;\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n            ReadableStreamDefaultControllerClose(readableController);\n        }\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableStream, TransformStream, WritableStream };\n//# sourceMappingURL=ponyfill.es2018.mjs.map"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","NumberIsNaN","Number","isNaN","x","rethrowAssertionErrorRejection","typeIsObject","createArrayFromList","elements","slice","IsFiniteNonNegativeNumber","v","IsNonNegativeNumber","Infinity","Call","F","V","args","TypeError","Function","prototype","apply","call","CreateAlgorithmFromUnderlyingMethod","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","PromiseCall","arg","fullArgs","concat","promiseResolvedWith","InvokeOrNoop","O","P","value","promiseRejectedWith","ValidateAndNormalizeHighWaterMark","highWaterMark","RangeError","MakeSizeAlgorithmFromSizeFunction","size","chunk","originalPromise","Promise","originalPromiseThen","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","reason","PerformPromiseThen","promise","onFulfilled","onRejected","uponPromise","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","SimpleQueue","[object Object]","this","_cursor","_size","_front","_elements","_next","_back","length","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","push","oldFront","newFront","oldCursor","newCursor","callback","i","node","front","cursor","ReadableStreamCreateReadResult","done","forAuthorCode","Object","obj","create","ReadableStreamReaderGenericInitialize","reader","stream","_forAuthorCode","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","CancelSteps","PullSteps","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_resolve","_reject","_readRequests","ReadableStreamFulfillReadRequest","shift","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStream","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","ReadableStreamDefaultReaderRead","hasOwnProperty","_disturbed","_readableStreamController","AsyncIteratorPrototype","getPrototypeOf","async","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","streamAsyncIteratorBrandCheckException","_asyncIteratorReader","result","_preventCancel","DequeueValue","container","pair","_queue","_queueTotalSize","EnqueueValueWithSize","ResetQueue","setPrototypeOf","defineProperty","enumerable","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","type","sizeAlgorithm","controller","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","state","_promise","wasAlreadyErroring","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","forEach","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","ready","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","e","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","startAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","r","peek","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","isAbortSignal","aborted","NativeDOMException","DOMException","DOMException$1","ctor","isDOMExceptionConstructor","message","Error","captureStackTrace","constructor","writable","configurable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","dest","preventClose","preventAbort","preventCancel","signal","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","next","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","_closeRequested","ReadableStreamClose","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableStreamError","SetUpReadableStreamDefaultController","pullAlgorithm","cancelAlgorithm","NumberIsInteger","isInteger","isFinite","Math","floor","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","buffer","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","ArrayBuffer","isView","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","byteLength","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","entry","ReadableByteStreamControllerHandleQueueDrain","viewE","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","readerType","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","destOffset","src","srcOffset","n","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","readIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ReadableStream","underlyingSource","InitializeReadableStream","String","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","mode","AcquireReadableStreamBYOBReader","readable","Boolean","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","AcquireReadableStreamAsyncIterator","asyncIterator","getIterator","IsTransformStream","TransformStreamError","_readable","TransformStreamErrorWritableAndUnblockWrite","TransformStreamDefaultControllerClearAlgorithms","_transformStreamController","_writable","TransformStreamSetBackpressure","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamDefaultController","IsTransformStreamDefaultController","defaultControllerBrandCheckException$1","_controlledTransformStream","TransformStreamDefaultControllerEnqueue","readableController","TransformStreamDefaultControllerTerminate","_transformAlgorithm","_flushAlgorithm","ReadableStreamDefaultControllerHasBackpressure","TransformStreamDefaultControllerPerformTransform","streamBrandCheckException$2","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","startPromise","CreateWritableStream","TransformStreamDefaultSinkWriteAlgorithm","flushPromise","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","InitializeTransformStream","transformAlgorithm","transformResultE","transformMethod","transform","flushAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","startResult"],"mappings":"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"}